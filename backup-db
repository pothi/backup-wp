#!/usr/bin/env fish

# set -l fish_trace on

# requirements
# ~/log, ~/backups, ~/path/to/example.com/public

set ver 1.0

### Variables - Please do not add trailing slash in the PATHs

# where to store the database backups?
set BACKUP_PATH {$HOME}/backups/db

# a passphrase for encryption, in order to being able to use almost any special characters use ""
# it's best to configure it in ~/.envrc file
set PASSPHRASE

# the script assumes your sites are stored like ~/sites/example.com, ~/sites/example.net, ~/sites/example.org and so on.
# if you have a different pattern, such as ~/app/example.com, please change the following to fit the server environment!
set SITES_PATH {$HOME}/sites

# To debug, use any value for "debug", otherwise please leave it empty
set debug

#-------- Do NOT Edit Below This Line --------#

# attempt to create log directory if it doesn't exist
if test ! -d {$HOME}/log
    mkdir -p ~/log
    if not test $status
        echo "Log directory not found at ~/log. This script can't create it, either!"
        echo 'You may create it manually and re-run this script.'
        exit 1
    end
end

set log_file {$HOME}/log/backups.log
# exec > >(tee -a "${log_file}")
# exec 2> >(tee -a "${log_file}" >&2)

# Variables defined later in the script
set script_name (status basename)
set timestamp (date +%F_%H-%M-%S)
set success_alert 
set custom_email 
set custom_wp_path 
set BUCKET_NAME 
set DOMAIN 
set PUBLIC_DIR public
set size
set sizeH

# get environment variables, if exists
# .envrc is in the following format
# export VARIABLE=value
# [ -f "$HOME/.envrc" ] && source ~/.envrc
# uncomment the following, if you use .env with the format "VARIABLE=value" (without export)
# if [ -f "$HOME/.env" ]; then; set -a; source ~/.env; set +a; fi

# Do something cool with "$@"... \o/

# Get example.com
set DOMAIN $argv[1]
set BUCKET_NAME $argv[2]

# Number of backups to keep
set NightlyBackupsToKeep 7
set WeeklyBackupsToKeep 4
set MonthlyBackupsToKeep 12

echo Domain: $DOMAIN

set SITE $DOMAIN
set DIR_NIGHTLY $BACKUP_PATH/nightly
set DIR_WEEKLY $BACKUP_PATH/weekly
set DIR_MONTHLY $BACKUP_PATH/monthly

test -d ~/tmp || mkdir -p ~/tmp
test -d "$DIR_NIGHTLY" || mkdir -p "$DIR_NIGHTLY"
test -d "$DIR_WEEKLY" || mkdir -p "$DIR_WEEKLY"
test -d "$DIR_MONTHLY" || mkdir -p "$DIR_MONTHLY"

set BACKUP_PATH $DIR_NIGHTLY

# check for backup dir
if test ! -d "$BACKUP_PATH"
    echo "BACKUP_PATH is not found at $BACKUP_PATH. This script can't create it, either!"
    echo You may create it manually and re-run this script.
    exit 1
end

command -v wp >/dev/null || { echo >&2 "wp cli is not found in $PATH. Exiting."; exit 1; }
command -v aws >/dev/null || { echo >&2 "[Warn]: aws cli is not found in $PATH. Offsite backups will not be taken!"; }
command -v mail >/dev/null || echo >&2 "[Warn]: 'mail' command is not found in \$PATH; Email alerts will not be sent!"

# set alertEmail ${custom_email:-${BACKUP_ADMIN_EMAIL:-${ADMIN_EMAIL:-"root@localhost"}}}
set alertEmail "root@localhost"

# Define paths

# convert forward slash found in sub-directories to hyphen
# ex: example.com/test would become example.com-test
set DOMAIN_FULL_PATH $(echo "$DOMAIN" | awk '{gsub(/\//,"-")}; 1')

set BACKUP_NAME $BACKUP_PATH/$DOMAIN_FULL_PATH-db-$timestamp.sql.gz
set LATEST_BACKUP $BACKUP_PATH/$DOMAIN_FULL_PATH-db-latest.sql.gz

set WP_PATH $SITES_PATH/$DOMAIN/$PUBLIC_DIR
# [ -d "$WP_PATH" ] || { echo >&2 "WordPress is not found at ${WP_PATH}"; exit 1; }

echo "'$script_name' started on... $(date +%c)"

echo WordPress PATH: $WP_PATH

# take actual DB backup
# 2>/dev/null to suppress any warnings / errors
wp --path="$WP_PATH" transient delete --all 2>/dev/null
if [ -n "$PASSPHRASE" ] ;
    set BACKUP_NAME "$BACKUP_NAME".gpg
    wp --path="$WP_PATH" db export --no-tablespaces=true --add-drop-table - | gzip | gpg --symmetric --passphrase "$PASSPHRASE" --batch -o "$BACKUP_NAME"
else
    wp --path="$WP_PATH" db export --no-tablespaces=true --add-drop-table - | gzip > "$BACKUP_NAME"
end
if test status
    printf "\nBackup is successfully taken locally."
else
    set msg "$script_name - [Error] Something went wrong while taking local DB backup!"
    printf "\n%s\n\n" "$msg"
    echo "$msg" | mail -s 'DB Backup Failure' "$alertEmail"
    [ -f "$BACKUP_NAME" ] && rm -f "$BACKUP_NAME"
    exit 1
end

set size $(du $BACKUP_NAME | awk '{print $1}')
set sizeH $(du -h $BACKUP_NAME | awk '{print $1}')

[ -L "$LATEST_BACKUP" ] && rm "$LATEST_BACKUP"
ln -s "$BACKUP_NAME" "$LATEST_BACKUP"

# send the backup offsite
if [ "$BUCKET_NAME" ];
    aws s3 cp $BACKUP_NAME s3://$BUCKET_NAME/$DOMAIN_FULL_PATH/db-backups/ --only-show-errors
    if test $status
        set msg "Offsite backup successful."
        printf "\n%s\n\n" "$msg"
        [ "$success_alert" ] && echo "$script_name - $msg" | mail -s 'Offsite Backup Info' "$alertEmail"
    else
        set msg "$script_name - [Error] Something went wrong while taking offsite backup."
        printf "\n%s\n\n" "$msg"
        echo "$msg" | mail -s 'Offsite Backup Info' "$alertEmail"
    end
end

# Weekly backup - Mondays
if test 1 -eq "$(date +%u)"
    cp $BACKUP_NAME $DIR_WEEKLY/
end

# Monthly backup - 1st of each month
if test 1 -eq "$(date +%e)"
    cp $BACKUP_NAME $DIR_MONTHLY/
end

# Auto delete backups
find -L $BACKUP_PATH/$DOMAIN_FULL_PATH-db-* -type f -mtime +$NightlyBackupsToKeep -exec rm {} \;
find -L $DIR_WEEKLY/$DOMAIN_FULL_PATH-db-*  -type f -mtime +$(math $WeeklyBackupsToKeep x 7)   -exec rm {} \;
find -L $DIR_MONTHLY/$DOMAIN_FULL_PATH-db-* -type f -mtime +$(math $MonthlyBackupsToKeep x 31) -exec rm {} \;


echo "Database backup is done; please check the latest backup in '$BACKUP_PATH'."
echo "Latest backup is at $BACKUP_NAME"
echo "Backup size: $size($sizeH)."

printf "Script ended on...%s\n\n" "$(date +%c)"

